<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Design on Nadia Humbert-Labeaumaz</title><link>https://nadia-humbert-labeaumaz.github.io/tags/software-design/</link><description>Recent content in Software Design on Nadia Humbert-Labeaumaz</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Nadia Humbert-Labeaumaz • 2021</copyright><lastBuildDate>Sun, 17 Sep 2017 16:09:24 +0200</lastBuildDate><atom:link href="https://nadia-humbert-labeaumaz.github.io/tags/software-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing Java Spring Boot Microservices</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2017/09/17/testing-java-spring-cloud-microservices/</link><pubDate>Sun, 17 Sep 2017 16:09:24 +0200</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2017/09/17/testing-java-spring-cloud-microservices/</guid><description>Tests are an essential part of our codebase. At the very least, they minimize the risk of regression when we modify our code. There are several types of tests and each has a specific role: unit tests, integration tests, component tests, contract tests and end-to-end tests.</description></item><item><title>How to Write Robust Component Tests</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2017/09/16/how-to-write-robust-component-tests/</link><pubDate>Sat, 16 Sep 2017 13:37:12 +0200</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2017/09/16/how-to-write-robust-component-tests/</guid><description>Component tests allow to test complete use cases from end to end. They are often expensive especially in terms of setup and execution time. Thus, thought needs to be given to define their scope.</description></item><item><title>Setup a Circuit Breaker with Hystrix, Feign Client and Spring Boot</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix/</link><pubDate>Sun, 23 Jul 2017 13:33:38 +0200</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix/</guid><description>In a microservices architecture, several things can go wrong. A middleware, the network or the service you want to contact can be down. In this world of uncertainty, you have to anticipate problems in order not to break the entire chain and throw an error to the end user when you could offer a partially degraded service instead.</description></item><item><title>Refactoring Conditional Structures with Map</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2017/07/20/refactoring-conditional-with-map/</link><pubDate>Thu, 20 Jul 2017 15:32:15 +0100</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2017/07/20/refactoring-conditional-with-map/</guid><description>When working on already existing codebases, I often encounter pieces of code that look like this:
public class Day { public void start(Weather weather) { switch(weather) { case RAINY: takeAnUmbrella(); break; case SUNNY: takeAHat(); break; case STORMY: stayHome(); break; default: doNothing(); break; } } } Basically, depending on the weather, an action has to be taken.</description></item><item><title>Gérer les dépendances circulaires</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2016/12/17/gerer-les-dependances-circulaires/</link><pubDate>Sat, 17 Dec 2016 18:31:18 +0100</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2016/12/17/gerer-les-dependances-circulaires/</guid><description>Durant mon travail, j&amp;rsquo;ai rencontré des dépendances circulaires dans une application sur laquelle je suis intervenue. Dans sa plus simple forme, il s&amp;rsquo;agit de deux classes qui dépendent l&amp;rsquo;une de l&amp;rsquo;autre.</description></item><item><title>Refactoring d'une application N-Tiers en utilisant le CQRS</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/</link><pubDate>Sun, 26 Jun 2016 18:14:40 +0200</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/</guid><description>CQRS, ou Command Query Responsibility Segregation, est une architecture où la partie Command (écriture) et la partie Query (lecture) du système sont séparées.
J&amp;rsquo;ai eu la chance d&amp;rsquo;assister récemment à une présentation de Tomasz Jaskula nommée Recettes CQRS, pour bien cuisiner son architecture.</description></item><item><title>Que faire lorsqu'une méthode privée veut être testée ?</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2016/02/21/que-faire-lorsqu-une-methode-privee-veut-etre-testee/</link><pubDate>Sun, 21 Feb 2016 11:09:38 +0100</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2016/02/21/que-faire-lorsqu-une-methode-privee-veut-etre-testee/</guid><description>Les tests automatisés servent à vérifier le bon comportement d&amp;rsquo;un objet (ou d&amp;rsquo;un ensemble d&amp;rsquo;objets), indépendamment de la manière dont ce comportement est implémenté. Le comportement d&amp;rsquo;un objet est décrit par son API publique (constructeurs, constantes et méthodes publiques).</description></item><item><title>Pourquoi ne pas utiliser l'héritage pour éviter la duplication de code ?</title><link>https://nadia-humbert-labeaumaz.github.io/blog/2016/01/24/heritage-duplication-code/</link><pubDate>Sun, 24 Jan 2016 11:38:41 +0100</pubDate><guid>https://nadia-humbert-labeaumaz.github.io/blog/2016/01/24/heritage-duplication-code/</guid><description>L&amp;rsquo;héritage est une composante très importante des langages orientés objet tels que Java. Cependant, il doit être utilisé à bon escient afin de respecter les bonnes pratiques de programmation.
Il m&amp;rsquo;est arrivé de rencontrer des cas où l&amp;rsquo;héritage était utilisé afin de ne pas dupliquer du code.</description></item></channel></rss>